%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.1 (25/3/14)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage[boxed]{algorithm2e} % required for algorithms
\usepackage{fancyhdr}

%\setlength\parindent{0pt} % Removes all indentation from paragraphs; ignore this

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

\pagestyle{fancy}
\fancyhf{}
\lhead{Whitacre School of Engineering}
\rhead{Texas Tech University}
\rfoot{\thepage}
\lfoot{TR 2015-001}

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{GoblinCore64: \\ Architectural Specification \\ Technical Report 2015-001} % Title

\author{John D. \textsc{Leidel}} % Author name

\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

\begin{center}
\begin{tabular}{l r}
Version: & 1.0 \\ % Date the experiment was performed
Texas Tech University \\ % Partner names
Data Intensive Scalable Computing Laboratory \\ % Course

\end{tabular}
\end{center}

\newpage

\tableofcontents

\newpage

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Introduction}

\subsection{GC64 Overview}

\subsection{RISC-V ISA Requirements}

The GC64 RISC-V extension functions as both a core RISC-V \cite{Waterman:EECS-2014-54} architectural extension and an extension to the standard 64-bit RISC-V IMAFD specification.  The following minimum architectural extensions are required to utilize GC64.  

\begin{itemize}
\item \textbf{RV64I}:  GC64 requires 64-bit addressing at minimum.  The RV32I memory model is supported as a result.  However, given the use of HMC devices, we require the use of at least 64-bit addressing (and addressing arithmetic).  
\item \textbf{M-Extension}:  GC64 requires the integer multiplication and division for the purpose of efficiently performing address manipulation.  
\item \textbf{A-Extension}: GC64 requires the atomic instructions.
\end{itemize}

The following architectural extensions are support in the GC64 tasking model.  They are herein named as optional extensions.  

\begin{itemize}
\item \textbf{F-Extension}:  By default, the GC64 task context definition supports the storage of the single precision floating point register values.  If the F-extension is not present, these values are ignored.  
\item \textbf{D-Extension}: By default, the GC64 task context definition supports the storage of the double precision floating point register values.  If the D-extension is not present, these values are ignored.  
\item \textbf{RV128I}: By default, the GC64 reuqires 64-bit addressing.  However, when building scalable versions of GC64 in large SMP or PGAS modes, it may be desirable to support 128bit addressing.  
\end{itemize}

\subsection{RISC-V SoC Architecture}

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------
\section{GC64 Instruction Set Extension}

\subsection{GC64 RISC-V Machine Organization}
\subsection{GC64 Register State}
In addition to the registers defined as a part of the base RISC-V IMAFD ISA, we define an additional set of registers for the GC64 extension.  The register extension is defined in terms of User-Visible, Supervisor and Machine-State registers.  User-Visible registers are those that can be read and written from normal user instructions.  Supervisor registers are those that can only be read and written from supervisor-privileged instructions.  Machine-State registers cannot be read or written from any instruction space.  Rather, these registers are implicitly modified during the normal operation of the core.     

\subsubsection{User-Visible Registers} 
The GC64 extension adds a register, \emph{tctx}, to the list of user-visible registers.  The \emph{tctx} register is an unsigned 64bit register that exists per task and contains the base address of the task that is currently loaded in the task unit. The \emph{tctx} register can be read from and written to using user-privileged instructions.  However, given that it resides outside the base RISC-V IMAFD register set, it can only be read from and written to using the \emph{gettask} and \emph{settask} instructions.  

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{TCTX}
\end{center}

The GC64 extension adds a task ID register, \emph{tid}, to the list of user-visible registers.  The \emph{tid} register contains an unsigned 64bit value that represents the task ID currently loaded in the respective task unit.  The \emph{tid} registers can be read from a single user-privileged instruction, \emph{gettid}.  

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{TID}
\end{center}

The GC64 extension also adds a configuration register, \emph{gconst} that is user-visible.  The \emph{gconst} register is an unsigned 64bit register that contains the configuration parameters for the containing task unit and GC64 processor.  The \emph{gconst} register can only be read.  It cannot be written to.  It can only be read via the \emph{getgconst} instruction.  The \emph{gconst} register contains the following fields.  

\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
Mnemonic & Bits & Size [Bits] & Description \\ 
\hline \hline
PID & [15:0] & 16 & Partition ID \\
\hline
NID & [31:16] & 16 & Node ID \\
\hline
SID & [39:32] & 8 & Socket ID \\
\hline
TG & [47:40] & 8 & Task Group \\
\hline 
TP & [55:48] & 8 & Task Processors per Task Group \\
\hline 
TC & [63:56] & 8 & Task Units per Task Processor \\
\hline 

\end{tabular}
\end{center} 

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{GCONST}
\end{center}

\subsubsection{Supervisor Registers}

The GC64 extension contains a single supervisor register.  This register is contained within each task unit and is referred to as the \emph{gkey} register.  The purpose of this register is to contain the security key loaded via the kernel and constructor routines at application launch such that rogue tasks cannot spawn tasks in the process space of a neighboring process.  Given the purpose of this register, it remains a part of the standard context for context save and restore operations.  This register is represented using as an unsigned 64bit value.  It can be read from and written to using the supervisor instructions \emph{gkey} and \emph{skey}.  

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{GKEY}
\end{center}

\subsubsection{Machine-State Registers}

The GC64 extension contains a single machine-state register.  This register, known as the \emph{gcount} register, is not directly readable or writable from any instructions.  Its value is similar in function to a traditional performance counter register.  Any time an instruction is retired through the pipeline, this value is incremented.  The increment value is dependent upon the cost of the retired instruction.  Once this counter reaches its maximum value as defined by the internal architecture state, the encountering task unit is forced to context switch and thus permit another task unit to execute.  The only method the user-privileged code has to indirectly access this register state is the \emph{peg} instruction.  The \emph{peg} instruction explicitly sets this register to its maximum value, thus forcing a context switch event.    

%------- INTEGER LOAD/STORE INSTRUCTIONS
\subsection{Integer Load/Store Instructions}

%-- integer gathers
\subsubsection{ldgthr rd, rs1, rs2}
\subsubsection{lwgthr rd, rs1, rs2}
\subsubsection{lhgthr rd, rs1, rs2}
\subsubsection{lbgthr rd, rs1, rs2}
\subsubsection{lwugthr rd, rs1, rs2}
\subsubsection{lhugthr rd, rs1, rs2}
\subsubsection{lbugthr rd, rs1, rs2}

%-- integer scatters: rs1 is the target
\subsubsection{sdscatr rs1, rs2, rs3}
\subsubsection{swscatr rs1, rs2, rs3}
\subsubsection{shscatr rs1, rs2, rs3}
\subsubsection{sbscatr rs1, rs2, rs3}

%------- SINGLE-PRECISION LOAD/STORE INSTRUCTIONS
\subsection{Single-Precision Load/Store Instructions}

%-- sp gathers
\subsubsection{flwgthr fd, rs1, rs2}

%-- sp scatters
\subsubsection{fswscatr rs1, rs2, fs3}

%------- DOUBLE-PRECISION LOAD/STORE INSTRUCTIONS
\subsection{Double-Precision Load/Store Instructions}

%-- sp gathers
\subsubsection{fldgthr fd, rs1, rs2}

%-- sp scatters
\subsubsection{fsdscatr rs1, rs2, fs3}

%------- CONCURRENCY INSTRUCTIONS
\subsection{Concurrency Instructions}
\subsubsection{iwait rd}
\subsubsection{future rd, rs1, rs2}

Pend the execution of the encountering task until the hazard
on the integer register specified by \emph{rd} has been cleared. 
The clear register state indicates that no outstanding load 
operations are in flight and no outstanding arithmetic 
operations are in the pipeline.  The encountering thread
pends as long as \emph{rs2} < \emph{rs1}.  The maximum number of cycles to
pend is \emph{rs1-rs2}.  The machine state adheres to the following state: 

\begin{algorithm}[H]
 \KwData{rd is the target integer register, rs1 is the max unsigned value to be, rs2 is the unsigned start value}
 \KwResult{The encountering task unit pends until rs2 is greater than or equal to rs1}
 \While{rs2 less than or equal to rs2}{
  rs2++;
 }
 clear future state
\end{algorithm}

\subsubsection{peg}

Implicitly set the \emph{gcount} machine state register
to its maximum value.  The result being a forcible context
switch of the encountering task.  If the task control logic
does not have any subsequent tasks ready for execution, then the
minimum context switch wait time is a single clock cycle.  

%------- TASK CONTROL INSTRUCTIONS
\subsection{Task Control Instructions}
\subsubsection{spawn rd, rs1}

Spawn a task using the task context at the address specified by the integer 
register \emph{rs1}.  Return the status of the spawn operation in the 
integer register \emph{rd}.  The address is considered to be a 64-bit virtual 
address at minimum.  When 128-bit addressing is enabled, it is permissible 
for the address to be 128-bits.  

\subsubsection{join rd, rs1}

Perform a task join operation on the task context specified 
by the integer register \emph{rs1}.  Return the status of the spawn operation
in the integer register \emph{rd}.  The address is considered to be a
64-bit virtual address at minimum.  When 128-bit addressing is enabled, it is
permissible for the address to be 128-bits. 

\subsubsection{gettask rd, tctx}

Retrieve the task context value for the encountering task unit.  
The value of the tctx register should be, at minimum, at 64-bit virtual
address.  Store the value to the integer register specified by \emph{rd}.  
When 128-bit addressing is enabled, it is permissible for the address to be 128-bits.

\subsubsection{settask tctx, rs1}

Set the task context value for the current task unit to the address value
specified by the integer register \emph{rs1} and store the value to the
\emph{tctx} register.  This is a 64-bit virtual address at minimum.  
When 128-bit addressing is enabled, it is permissible for the address to be 128-bits.


\subsubsection{gettid rd, gtid}

Retrieve the taskid value from the encountered task and write the value
to the integer register specified by \emph{rd}.

%------- ENVIRONMENT INSTRUCTIONS
\subsection{Environment Instructions}
\subsubsection{getgconst rd, gconst}

Retrieve the value of the GC64 constant register \emph{gconst}.  Write
the value into the integer register specified by \emph{rd}.

%------- SUPERVISOR INSTRUCTIONS
\subsection{Supervisor Instructions}
\subsubsection{sgetkey rd, gkey}

Retrieve the value of the current GC64 security key.  Write
the result to the integer register specified by \emph{rd}.  This
instruction may only be executed by tasks with supervisor privileges. 

\subsubsection{ssetkey gkey, rs1}

Set the value of the current GC64 security key.  The value is written
from the integer register specified by \emph{rs1}.  This instruction
may only be executed by tasks with supervisor privileges.  

%------- 128-bit INTEGER LOAD/STORE INSTRUCTIONS
\subsection{[Optional] 128-bit Integer Load/Store Instructions}

%-- 128-bit integer gathers
\subsubsection{lqgthr rd, rs1, rs2}
\subsubsection{ldugthr rd, rs1, rs2}

%-- 128-bit integer scatters
\subsubsection{sqscatr rs1, rs2, rs3}

%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------
\section{GC64 Task Interface Specification}

\subsection{Overview}

\subsection{Task Context}

\subsection{Task Queuing}

%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------
\section{GC64 Instruction Set Listings}

\framebox[15ex][s]{foobar}

%----------------------------------------------------------------------------------------
%	SECTION 5
%----------------------------------------------------------------------------------------
\section{History and Acknowledgements}

This project is sponsored by the Data Intensive Scalable Computing Laboratory in the Whitacre School of Engineering at Texas Tech University.  The original GoblinCore64 Instruction Set Architecture and concept began in 2013 as a stand-alone ISA without dependence upon any external projects.  However, given the emergence of the RISC-V project from the University of California, Berkeley, and the inherent synergies with their design decisions, we decided to migrate the base GC64 ISA to the RISC-V infrastructure.   

%----------------------------------------------------------------------------------------
%	SECTION 6
%----------------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{gc64-arch-spec}

\end{document}
