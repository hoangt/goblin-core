%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.1 (25/3/14)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage[boxed]{algorithm2e} % required for algorithms
\usepackage{fancyhdr}

%\setlength\parindent{0pt} % Removes all indentation from paragraphs; ignore this

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

\pagestyle{fancy}
\fancyhf{}
\lhead{Whitacre School of Engineering}
\rhead{Texas Tech University}
\rfoot{\thepage}
\lfoot{TR 2015-001}

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{GoblinCore64: \\ Architectural Specification \\ Technical Report 2015-001} % Title

\author{John D. \textsc{Leidel}} % Author name

\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

\begin{center}
\begin{tabular}{l r}
Version: & 1.0 \\ % Date the experiment was performed
Texas Tech University \\ % Partner names
Data Intensive Scalable Computing Laboratory \\ % Course

\end{tabular}
\end{center}

\newpage

\tableofcontents

\newpage

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Introduction}

\subsection{GC64 Overview}

\subsection{RISC-V ISA Requirements}

The GC64 RISC-V extension functions as both a core RISC-V architectural extension and an extension to the standard 64-bit RISC-V IMAFD specification.  The following minimum architectural extensions are required to utilize GC64.  

\begin{itemize}
\item \textbf{RV64I}:  GC64 requires 64-bit addressing at minimum.  The RV32I memory model is supported as a result.  However, given the use of HMC devices, we require the use of at least 64-bit addressing (and addressing arithmetic).  
\item \textbf{M-Extension}:  GC64 requires the integer multiplication and division for the purpose of efficiently performing address manipulation.  
\item \textbf{A-Extension}:
\end{itemize}

The following architectural extensions are support in the GC64 tasking model.  They are herein named as optional extensions.  

\begin{itemize}
\item \textbf{F-Extension}:  By default, the GC64 task context definition supports the storage of the single precision floating point register values.  If the F-extension is not present, these values are ignored.  
\item \textbf{D-Extension}: By default, the GC64 task context definition supports the storage of the double precision floating point register values.  If the D-extension is not present, these values are ignored.  
\end{itemize}

\subsection{RISC-V SoC Architecture}

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------
\section{GC64 Instruction Set Extension}

\subsection{GC64 RISC-V Machine Organization}
\subsection{GC64 Register State}
In addition to the registers defined as a part of the base RISC-V IMAFD ISA, we define an additional set of registers for the GC64 extension.  The register extension is defined in terms of User-Visible, Supervisor and Machine-State registers.  User-Visible registers are those that can be read and written from normal user instructions.  Supervisor registers are those that can only be read and written from supervisor-privileged instructions.  Machine-State registers cannot be read or written from any instruction space.  Rather, these registers are implicitly modified during the normal operation of the core.     

\subsubsection{User-Visible Registers} 
The GC64 extension adds a register, \emph{tctx}, to the list of user-visible registers.  The \emph{tctx} register is an unsigned 64bit register that exists per task and contains the base address of the task that is currently loaded in the task unit. The \emph{tctx} register can be read from and written to using user-privileged instructions.  However, given that it resides outside the base RISC-V IMAFD register set, it can only be read from and written to using the \emph{gettask} and \emph{settask} instructions.  

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{TCTX}
\end{center}

The GC64 extension adds a task ID register, \emph{tid}, to the list of user-visible registers.  The \emph{tid} register contains an unsigned 64bit value that represents the task ID currently loaded in the respective task unit.  The \emph{tid} registers can be read from a single user-privileged instruction, \emph{gettid}.  

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{TID}
\end{center}

The GC64 extension also adds a configuration register, \emph{gconst} that is user-visible.  The \emph{gconst} register is an unsigned 64bit register that contains the configuration parameters for the containing task unit and GC64 processor.  The \emph{gconst} register can only be read.  It cannot be written to.  It can only be read via the \emph{getgconst} instruction.  The \emph{gconst} register contains the following fields.  

\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
Mnemonic & Bits & Size [Bits] & Description \\ 
\hline \hline
PID & [15:0] & 16 & Partition ID \\
\hline
NID & [31:16] & 16 & Node ID \\
\hline
SID & [39:32] & 8 & Socket ID \\
\hline
TG & [47:40] & 8 & Task Group \\
\hline 
TP & [55:48] & 8 & Task Processors per Task Group \\
\hline 
TC & [63:56] & 8 & Task Units per Task Processor \\
\hline 

\end{tabular}
\end{center} 

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{GCONST}
\end{center}

\subsubsection{Supervisor Registers}

The GC64 extension contains a single supervisor register.  This register is contained within each task unit and is referred to as the \emph{gkey} register.  The purpose of this register is to contain the security key loaded via the kernel and constructor routines at application launch such that rogue tasks cannot spawn tasks in the process space of a neighboring process.  Given the purpose of this register, it remains a part of the standard context for context save and restore operations.  This register is represented using as an unsigned 64bit value.  It can be read from and written to using the supervisor instructions \emph{gkey} and \emph{skey}.  

\begin{center}
\makebox[\textwidth][s]{63 0}
\framebox[\textwidth][c]{GKEY}
\end{center}

\subsubsection{Machine-State Registers}

The GC64 extension contains a single machine-state register.  This register, known as the \emph{gcount} register, is not directly readable or writable from any instructions.  Its value is similar in function to a traditional performance counter register.  Any time an instruction is retired through the pipeline, this value is incremented.  The increment value is dependent upon the cost of the retired instruction.  Once this counter reaches its maximum value as defined by the internal architecture state, the encountering task unit is forced to context switch and thus permit another task unit to execute.  The only method the user-privileged code has to indirectly access this register state is the \emph{peg} instruction.  The \emph{peg} instruction explicitly sets this register to its maximum value, thus forcing a context switch event.    

\subsection{Integer Load/Store Instructions}
\subsection{Single-Precision Load/Store Instructions}
\subsection{Double-Precision Load/Store Instructions}
\subsection{Concurrency Instructions}
\subsection{Task Control Instructions}
\subsection{Supervisor Instructions}

%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------
\section{GC64 Task Interface Specification}

\subsection{Overview}

\subsection{Task Context}

\subsection{Task Queuing}

%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------
\section{GC64 Instruction Set Listings}

\framebox[15ex][s]{foobar}

%----------------------------------------------------------------------------------------
%	SECTION 5
%----------------------------------------------------------------------------------------
\section{History and Acknowledgements}

This project is sponsored by the Data Intensive Scalable Computing Laboratory in the Whitacre School of Engineering at Texas Tech University.  The original GoblinCore64 Instruction Set Architecture and concept began in 2013 as a stand-alone ISA without dependence upon any external projects.  However, given the emergence of the RISC-V project from the University of California, Berkeley, and the inherent synergies with their design decisions, we decided to migrate the base GC64 ISA to the RISC-V infrastructure.   
\end{document}